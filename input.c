#define _POSIX_C_SOURCE 200809L#include <stddef.h>#include <stdio.h>#include <stdlib.h>#include <stdbool.h>#include <ctype.h>#include <errno.h>#include "input.h"#include "errors.h"#include "simulation.h"#define power2To32 4294967296int hexToInt(char c) {    if (c >= '0' && c <= '9') {        return c - '0';    } else if (c >= 'a' && c <= 'f') {        return c - 'a' + 10;    } else if (c >= 'A' && c <= 'F') {        return c - 'A' + 10;    }    return -1;}/** * Function reads signs after 'x' and writes them to array, returns array. * FUnction reads and  writes to the array signs after 'x' * in '0x' format of 4-th input line. * @param array – the array signs will be written to. * @param line – pointer to a scanned line, signs will be red from it. * @param index – index, of 'x' position in scanned line. * @param err – the pointer, set on 1, if error was found. * @return array which contains hex number (number after '0x'). */static charArray *readCharsAfterX(charArray *array, const char *line, size_t index, int *err) {    if (isspace(line[index])) {        *err = 1;        return NULL;    }    do {        if (isxdigit(line[index])) {            if (hexToInt(line[index]) == -1) {                *err = 1;                break;            }            pushBackChar(array, line[index]);        }        index++;    } while (isxdigit(line[index]));    while (line[index] != '\n' && isspace(line[index])) {        index++;    }    if (line[index] != '\n' && (int)line[index] != 0) {        *err = 1;    }    return array;}static void scanLine(char **line, int *err) {    size_t bufferSize = 0;    size_t lineLength = getline(line, &bufferSize, stdin);    if (errno == ENOMEM) {        free(*line);        *line = NULL;        handleError(0);    }    if (lineLength == (size_t) (-1)) {        *err = 1;        free(*line);        *line = NULL;    }}static void scanToArrayAdd(Array *arr, int *err, char *line) {    size_t i = 0;    size_t number;    if (*err == 1) return;    while (line[i] != '\n' && line[i] != EOF) {        while (isspace(line[i]) && line[i] != '\n' && line[i] != EOF) {            i++;        }        if (isdigit(line[i])) {            number = strtoull(line + i, NULL, 10);            if (errno == ERANGE) {                *err = 1;                break;            }            pushBack(arr, number);        } else if (line[i] == '\n' || line[i] == EOF) {            if (getLength(arr) == 0) {                *err = 1;            }            break;        } else {            if ((int)line[i] != 0) {                *err = 1;            }            break;        }        while (isdigit(line[i])) i++;    }    if (getLength(arr) == 0) {        *err = 1;    }}static void scanToArray(Array *arr, int *err) {    char *line = NULL;    scanLine(&line, err);    scanToArrayAdd(arr, err, line);    if (line != NULL) {        free(line);        line = NULL;    }}/** * Function convert R-format 4-th line to binary array. * @param rests – calculated by formula rests. * @param volume – volume of maze. * @param bitPositions – the array(hex) with stores info if cells are empty. */static void convertRToBinary(Array *rests, size_t volume, charArray *bitPositions) {    long long difference;    for (size_t i = 0; i < (volume / 4) + 1; i++) {        pushBackChar(bitPositions, '0');    }    for (size_t i = 1; i < getLength(rests); i++) {        size_t element = getElementFromArray(rests, i);        difference = (long long) (volume - element);        while (difference >= 0) {            setBit(bitPositions, element);            difference -= power2To32;            element += power2To32;        }    }}/** * Function converts R-number from 4-th input line to hex number. * @param numbers – the array of five scanned numbers after 'R'. * @param bitPositions  – the array(hex) with stores info if cells are empty. * @param dimensionArray – the array of maze's dimensions. * @param err – the pointer to error variable. */static void convertRNumber(Array *numbers, charArray *bitPositions, Array *dimensionArray, int *err) {    if (*err == 1) return;    size_t a, b, m, s_0, r;    size_t product;    a = getElementFromArray(numbers, 0);    b = getElementFromArray(numbers, 1);    m = getElementFromArray(numbers, 2);    r = getElementFromArray(numbers, 3);    s_0 = getElementFromArray(numbers, 4);    if (m == 0) {        *err = 1;        return;    }    Array *s = createArray();    Array *rests = createArray();    pushBack(s, s_0);    for (size_t i = 1; i <= r; i++) {        size_t result = (a * getElementFromArray(s, i - 1) + b) % m;        pushBack(s, result);    }    pushBack(rests, 0);    product = findVolume(dimensionArray);    for (size_t i = 1; i <= r; i++) {        pushBack(rests, getElementFromArray(s, i) % product);    }    size_t volume = findVolume(dimensionArray);    convertRToBinary(rests, volume, bitPositions);    deleteArray(s);    deleteArray(rests);}/** * Function to scan 4-th line of input. * Function helps to scan 4-th line depending on its' * type (hex, started with'0x' or R-number). * @param bitPositions – the array(hex), where converted 4-th line will be stored. * @param dimensionArray – the array of maze's dimensions. * @param err – the pointer, set on 1, if error was found. */static void scanHexOrR(charArray *bitPositions, Array *dimensionArray, int *err) {    char *line = NULL;    size_t i = 0;    bool hasZero = false;    scanLine(&line, err);    if (*err == 1) {        free(line);        return;    }    while (isspace(line[i]) || line[i] == '0') {        if (line[i] == '0') {            hasZero = true;        }        i++;    }    if (line[i] == 'R') {        Array *numbers = createArray();        scanToArrayAdd(numbers, err, line + i + 1);        if ((getLength(numbers) != 5) || (checkRInput(numbers, err) == false)) {            deleteArray(numbers);            free(line);            *err = 1;            return;        }        convertRNumber(numbers, bitPositions, dimensionArray, err);        deleteArray(numbers);    } else if (line[i] == 'x' && hasZero) {        if (i > 0 && line[i-1]!= '0') {            *err = 1;            return;        }        i++;        readCharsAfterX(bitPositions, line, i, err);        if (*err == 0) {            checkVolume(bitPositions, findVolume(dimensionArray), err);        }    } else if (line[i] == '\n') {        if (getLengthChar(bitPositions) == 0) {            *err = 1;        }    } else {        *err = 1;    }    free(line);}void readInput(Array *dimensionArray, Array *startArray, Array *endArray, charArray *bitPositions, int *err) {    scanToArray(dimensionArray, err);    checkInput(dimensionArray, err);    if (*err == 1) {        handleError(1);        return;    }    scanToArray(startArray, err);    checkInput(startArray, err);    checkArraysLength(startArray, dimensionArray, err);    if (*err == 1) {        handleError(2);        return;    }    scanToArray(endArray, err);    checkInput(endArray, err);    checkArraysLength(endArray, dimensionArray, err);    if (*err == 1) {        handleError(3);        return;    }    checkDimensions(dimensionArray, startArray, endArray, bitPositions, err);    checkStartEndBounds(dimensionArray, startArray, endArray, bitPositions);    if (*err == 1) {        handleError(1);        return;    }    scanHexOrR(bitPositions, dimensionArray, err);    if (*err == 1) {        handleError(4);        return;    }}